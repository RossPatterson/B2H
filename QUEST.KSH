#!/bin/ksh
# (c) Copyright 1996 IBM Corp.
# Ray Hawkes, HAWKESR at WTSCPOK, Ray_Hawkes@us.ibm.com   11 November 1996
#
# quest - CGI script to respond to answers to questions sent via a HTML FORM
# 
# This program validates the user input to a HTML FORM which gathers 
# answers to questions.
# The HTML form is expected to be generated by B2H, but could be generated
# by any means as long as the correct fields are present.
# Both GET and POST request methods are supported.
#
# Expected fields are:
# id=    Question ID (REQUIRED) - unused if answer file not used
#        (from ID= attribute in BookMaster)
# form=  Question type (REQUIRED) - One of: FILLIN/TF/MC/MATCH/ORDER
#        (from FORM= attribute in BookMaster)
# help=  Request Help (OPTIONAL) - if present, help is displayed and ALL
#        other fields are ignored.
# ans=   Actual answers (OPTIONAL) - a string of answers separated by space.
#        If not present, answers are read from an answer file in the format:
#          form:id:ans:reserved
#        If no answer available, user input cannot be validated and an
#        appropraite message is displayed
#        (built by B2H from ANS=, ANSID= attributes in BookMaster QUESTION,
#        BLANK, MATCH & QITEM tags)
# inp=   User input (OPTIONAL, may occur multiple times) - if not present,
#        a message is displayed
# The number of words in ans= must match the number of occurrences of inp=
#
# Uses cgiparse (part of IBM Internet Connection Server & other servers)

# The cgiparse program should be in the same directory as this script
CGIDIR=`dirname $0`

# If an answer file is used, this is where to find it
ANSFILE=$CGIDIR/answers.dat

# Set attributes for HTML BODY tag (e.g. BGCOLOR, BACKGROUND)
BODYATT="BGCOLOR=#FFFFFF"

# For debugging, uncomment the following line
#DEBUG=1

# Save args in case error needs to be displayed
ARGS="$*"

# Function cgihead - create an HTML header
# the title is passed as the first parameter
cgihead() {
echo "Content-type: text/html

<HTML><HEAD>
<TITLE>$1</TITLE>
</HEAD><BODY ${BODYATT}>
<H1>$1</H1>
"
} # cgihead

# Function cgiexit - close the HTML document and exit
# the return_code is passed as the first parameter
cgiexit() {
echo "</BODY></HTML>"
exit $1
} # cgiexit

# Function cgierror - display an HTML page of error info, then exit
# an error_message is passed as the first parameter
cgierror() {
cgihead "CGI script error"
echo "
<H2>Error</H2>
<P>$1"
if [ "$DEBUG" ]
then echo "<P>Arguments: $ARGS <P>Environment:
<PRE>`set|sed 's/</\&lt;/g`</PRE>"
fi
cgiexit 100
} # cgierror

########################################################################
## Main Script

# Initialize QUERY_STRING (if POST method)
eval `$CGIDIR/cgiparse -init`

# Initialize FORM_* variables from QUERY_STRING
eval `$CGIDIR/cgiparse -form -sep ' '`

if [ -z "$QUERY_STRING" -o -z "$FORM_id" -o -z "$FORM_form" ]
then
  cgierror "One or more required fields not supplied!"
fi

if [ -n "$FORM_help" ]
then
  cgihead "Question Help"
  echo "<P>Select or enter your answer and press the 'Send Answer' button.
<P>To clear the input fields press the 'Reset' button.
<P>A question must be answered exactly right to be CORRECT, partial answers
are treated as INCORRECT.
<P>The question types are:
<UL>
<LI>Fill-in-the-blanks Question 
<P>Fill-in each blank (usually with a single word).  Answers are not case
sensitive.  If multiple blanks are shown, all must be filled in.
The order must match the order specified in the answer to be correct.
</P>
<LI>True/False Question 
<P>Select the True or False radio button.
</P>
<LI>Multiple Choice Question 
<P>Select the checkbox(es) next to the correct answer(s). 
The number of correct answers should be obvious from the question.
The exact number of checkboxes must be selected to be correct.
</P>
<LI>Matching Question 
<P>Enter the matching item NUMBER in each entry field.  This should be a 
numeric digit with no other characters.
</P>
<LI>Ordering Question 
<P>Enter the sequence NUMBER in each entry field.  This should be a 
numeric digit with no other characters.
</P>
</UL>
"
  cgiexit 0
fi

# Work out how many ans= values are supplied
NUMANS=`$CGIDIR/cgiparse -count -value ans`

if [ "$NUMANS" -eq 0 ]            # no ans= fields from FORM
then
  if [ -r "$ANSFILE" ]            # check if we have an answer file
  then
    FORM_ans=`awk -F: "/^$FORM_form:$FORM_id:/"'{print $3}' $ANSFILE`
  fi
elif [ "$NUMANS" -gt 1 ]          # >1 ans= field - should not happen!
then
  cgierror "Oops! Something is wrong here.
<BR>There should only be 1 answer field, but there are $NUMANS!"
fi

if [ -z "$FORM_ans" ]             # no ans= values from FORM or answer file
then
  ACTION=NOANS
else                              # 1 ans= value - this is normal
  NUMINP=`$CGIDIR/cgiparse -count -value inp`
  set -- `echo $FORM_ans | tr '[:lower:]' '[:upper:]'`
  NUMANS=$#                       # number of answer values
  if [ $NUMINP -eq $NUMANS ]
  then
    NUMBL=0
    ACTION=RIGHT
    i=1
    for VALANS
    do
      VALINP=`$CGIDIR/cgiparse -$i -value inp | tr '[:lower:]' '[:upper:]'`
      if [ "$VALINP" = "" ]
      then let NUMBL=NUMBL+1
      elif [ "$VALANS" != "$VALINP" ]
      then ACTION=WRONG
      fi
      let i=i+1
    done
  fi
  case "$FORM_form" in
  FILLIN)
    HEAD="Answer to fill-in-the-blanks question"
    if [ $NUMINP -ne $NUMANS ]
    then ACTION=ERRBL
    elif [ $NUMBL -gt 0 ]
    then ACTION=NUMBL
    fi
    ;;
  TF)
    HEAD="Answer to true/false question"
    if [ $NUMINP -eq 0 ]
    then ACTION=NOINP
    elif [ $NUMINP -ne $NUMANS ]
    then ACTION=ERRBL
    fi
    ;;
  MC)
    HEAD="Answer to multi-choice question"
    if [ $NUMINP -eq 0 ]
    then ACTION=NOINP
    elif [ $NUMINP -ne $NUMANS ]
    then ACTION=NUMMC
    fi
    ;;
  MATCH)
    HEAD="Answer to matching question"
    if [ $NUMINP -ne $NUMANS ]
    then ACTION=ERRBL
    elif [ $NUMBL -gt 0 ]
    then ACTION=NUMBL
    fi
    ;;
  ORDER)
    HEAD="Answer to ordering question"
    if [ $NUMINP -ne $NUMANS ]
    then ACTION=ERRBL
    elif [ $NUMBL -gt 0 ]
    then ACTION=NUMBL
    fi
    ;;
  *) cgierror "Invalid question type: form=${FORM_form}"
    ;;
  esac
fi

# There are a number of actions for two reasons:
# a. To enable better messages to be returned for invalid input
# b. To distinguish WRONG answers from INCOMPLETE answers (e.g. when tracking
#    user responses & generating statistics - Not implemented).
case "$ACTION" in
ERRBL) cgierror "Oops! Something is wrong here.
<BR>There is a different number of responses ($NUMINP)
to the number of answers ($NUMANS)!"
  ;;
NOANS) 
  HEAD="No Answers Available"
  BODY="<P>There was no answer information supplied, so I don't know
if you were correct or not, sorry!"
  ;;
NOINP) BODY="<P>You did not answer the question.  Try again."
  ;;
NUMBL) BODY="<P>You did not fill in $NUMBL blank(s).  Try again."
  ;;
NUMMC) BODY="<P>You chose $NUMINP answers, but you should have 
chosen $NUMANS.  Try again."
  ;;
RIGHT) BODY="<P>You are <B>correct</B>, <BLINK>congratulations!</BLINK>"
  ;;
WRONG) BODY="<P>You are <B>incorrect</B>, better luck next time."
  ;;
esac

# for debugging, you want all variables - cgierror does this
if [ "$DEBUG" ]
then
  cgierror "<B>${HEAD}</B>
<P>${BODY}
<P>Your answer was: ${FORM_inp}
<P>The correct answer was: ${FORM_ans}"
fi

# Output the response
cgihead "${HEAD}"
echo "${BODY}"
cgiexit 0
